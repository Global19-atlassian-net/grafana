{"version":3,"file":"lokiPlugin.fb2366366adbbbf1d38b.js","sources":["webpack:///webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/WebSocketSubject.js","webpack:///webpack:///./node_modules/rxjs/_esm5/internal/observable/dom/webSocket.js","webpack:///webpack:///./node_modules/rxjs/_esm5/webSocket/index.js","webpack:///webpack:///./public/app/plugins/datasource/loki/LokiAnnotationsQueryCtrl.tsx","webpack:///webpack:///./public/app/plugins/datasource/loki/components/LokiCheatSheet.tsx","webpack:///webpack:///./public/app/plugins/datasource/loki/components/LokiQueryEditor.tsx","webpack:///webpack:///./public/app/plugins/datasource/loki/components/LokiQueryField.tsx","webpack:///webpack:///./public/app/plugins/datasource/loki/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/language_provider.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/live_streams.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/module.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/query_utils.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/result_transformer.ts","webpack:///webpack:///./public/app/plugins/datasource/loki/syntax.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/add_label_to_query.ts","webpack:///webpack:///./public/app/plugins/datasource/prometheus/language_utils.ts"],"sourcesContent":["/** PURE_IMPORTS_START tslib,_.._Subject,_.._Subscriber,_.._Observable,_.._Subscription,_.._ReplaySubject PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { ReplaySubject } from '../../ReplaySubject';\nvar DEFAULT_WEBSOCKET_CONFIG = {\n    url: '',\n    deserializer: function (e) { return JSON.parse(e.data); },\n    serializer: function (value) { return JSON.stringify(value); },\n};\nvar WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT = 'WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }';\nvar WebSocketSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(WebSocketSubject, _super);\n    function WebSocketSubject(urlConfigOrSource, destination) {\n        var _this = _super.call(this) || this;\n        if (urlConfigOrSource instanceof Observable) {\n            _this.destination = destination;\n            _this.source = urlConfigOrSource;\n        }\n        else {\n            var config = _this._config = tslib_1.__assign({}, DEFAULT_WEBSOCKET_CONFIG);\n            _this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                config.url = urlConfigOrSource;\n            }\n            else {\n                for (var key in urlConfigOrSource) {\n                    if (urlConfigOrSource.hasOwnProperty(key)) {\n                        config[key] = urlConfigOrSource[key];\n                    }\n                }\n            }\n            if (!config.WebSocketCtor && WebSocket) {\n                config.WebSocketCtor = WebSocket;\n            }\n            else if (!config.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            _this.destination = new ReplaySubject();\n        }\n        return _this;\n    }\n    WebSocketSubject.prototype.lift = function (operator) {\n        var sock = new WebSocketSubject(this._config, this.destination);\n        sock.operator = operator;\n        sock.source = this;\n        return sock;\n    };\n    WebSocketSubject.prototype._resetState = function () {\n        this._socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    };\n    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n        var self = this;\n        return new Observable(function (observer) {\n            try {\n                self.next(subMsg());\n            }\n            catch (err) {\n                observer.error(err);\n            }\n            var subscription = self.subscribe(function (x) {\n                try {\n                    if (messageFilter(x)) {\n                        observer.next(x);\n                    }\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n            return function () {\n                try {\n                    self.next(unsubMsg());\n                }\n                catch (err) {\n                    observer.error(err);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    };\n    WebSocketSubject.prototype._connectSocket = function () {\n        var _this = this;\n        var _a = this._config, WebSocketCtor = _a.WebSocketCtor, protocol = _a.protocol, url = _a.url, binaryType = _a.binaryType;\n        var observer = this._output;\n        var socket = null;\n        try {\n            socket = protocol ?\n                new WebSocketCtor(url, protocol) :\n                new WebSocketCtor(url);\n            this._socket = socket;\n            if (binaryType) {\n                this._socket.binaryType = binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        var subscription = new Subscription(function () {\n            _this._socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = function (e) {\n            var _socket = _this._socket;\n            if (!_socket) {\n                socket.close();\n                _this._resetState();\n                return;\n            }\n            var openObserver = _this._config.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            var queue = _this.destination;\n            _this.destination = Subscriber.create(function (x) {\n                if (socket.readyState === 1) {\n                    try {\n                        var serializer = _this._config.serializer;\n                        socket.send(serializer(x));\n                    }\n                    catch (e) {\n                        _this.destination.error(e);\n                    }\n                }\n            }, function (e) {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));\n                }\n                _this._resetState();\n            }, function () {\n                var closingObserver = _this._config.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                _this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(_this.destination));\n            }\n        };\n        socket.onerror = function (e) {\n            _this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = function (e) {\n            _this._resetState();\n            var closeObserver = _this._config.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = function (e) {\n            try {\n                var deserializer = _this._config.deserializer;\n                observer.next(deserializer(e));\n            }\n            catch (err) {\n                observer.error(err);\n            }\n        };\n    };\n    WebSocketSubject.prototype._subscribe = function (subscriber) {\n        var _this = this;\n        var source = this.source;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this._socket) {\n            this._connectSocket();\n        }\n        this._output.subscribe(subscriber);\n        subscriber.add(function () {\n            var _socket = _this._socket;\n            if (_this._output.observers.length === 0) {\n                if (_socket && _socket.readyState === 1) {\n                    _socket.close();\n                }\n                _this._resetState();\n            }\n        });\n        return subscriber;\n    };\n    WebSocketSubject.prototype.unsubscribe = function () {\n        var _socket = this._socket;\n        if (_socket && _socket.readyState === 1) {\n            _socket.close();\n        }\n        this._resetState();\n        _super.prototype.unsubscribe.call(this);\n    };\n    return WebSocketSubject;\n}(AnonymousSubject));\nexport { WebSocketSubject };\n//# sourceMappingURL=WebSocketSubject.js.map\n","/** PURE_IMPORTS_START _WebSocketSubject PURE_IMPORTS_END */\nimport { WebSocketSubject } from './WebSocketSubject';\nexport function webSocket(urlConfigOrSource) {\n    return new WebSocketSubject(urlConfigOrSource);\n}\n//# sourceMappingURL=webSocket.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport { webSocket as webSocket } from '../internal/observable/dom/webSocket';\nexport { WebSocketSubject } from '../internal/observable/dom/WebSocketSubject';\n//# sourceMappingURL=index.js.map\n","/**\n * Just a simple wrapper for a react component that is actually implementing the query editor.\n */\nexport class LokiAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  annotation: any;\n\n  /** @ngInject */\n  constructor() {\n    this.annotation.target = this.annotation.target || {};\n    this.onQueryChange = this.onQueryChange.bind(this);\n  }\n\n  onQueryChange(expr: string) {\n    this.annotation.expr = expr;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport { shuffle } from 'lodash';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/ui';\nimport LokiLanguageProvider from '../language_provider';\n\nconst DEFAULT_EXAMPLES = ['{job=\"default/prometheus\"}'];\nconst PREFERRED_LABELS = ['job', 'app', 'k8s_app'];\nconst EXAMPLES_LIMIT = 5;\n\nexport default class LokiCheatSheet extends PureComponent<ExploreStartPageProps, { userExamples: string[] }> {\n  userLabelTimer: NodeJS.Timeout;\n  state = {\n    userExamples: DEFAULT_EXAMPLES,\n  };\n\n  componentDidMount() {\n    this.scheduleUserLabelChecking();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.userLabelTimer);\n  }\n\n  scheduleUserLabelChecking() {\n    this.userLabelTimer = setTimeout(this.checkUserLabels, 1000);\n  }\n\n  checkUserLabels = async () => {\n    // Set example from user labels\n    const provider: LokiLanguageProvider = this.props.datasource.languageProvider;\n    if (provider.started) {\n      const labels = provider.getLabelKeys() || [];\n      const preferredLabel = PREFERRED_LABELS.find(l => labels.includes(l));\n      if (preferredLabel) {\n        const values = await provider.getLabelValues(preferredLabel);\n        const userExamples = shuffle(values)\n          .slice(0, EXAMPLES_LIMIT)\n          .map(value => `{${preferredLabel}=\"${value}\"}`);\n        this.setState({ userExamples });\n      }\n    } else {\n      this.scheduleUserLabelChecking();\n    }\n  };\n\n  renderExpression(expr: string) {\n    const { onClickExample } = this.props;\n\n    return (\n      <div\n        className=\"cheat-sheet-item__example\"\n        key={expr}\n        onClick={e => onClickExample({ refId: 'A', expr } as DataQuery)}\n      >\n        <code>{expr}</code>\n      </div>\n    );\n  }\n\n  render() {\n    const { userExamples } = this.state;\n\n    return (\n      <div>\n        <h2>Loki Cheat Sheet</h2>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">See your logs</div>\n          <div className=\"cheat-sheet-item__label\">Start by selecting a log stream from the Log labels selector.</div>\n          <div className=\"cheat-sheet-item__label\">\n            Alternatively, you can write a stream selector into the query field:\n          </div>\n          {this.renderExpression('{job=\"default/prometheus\"}')}\n          {userExamples !== DEFAULT_EXAMPLES && userExamples.length > 0 ? (\n            <div>\n              <div className=\"cheat-sheet-item__label\">Here are some example streams from your logs:</div>\n              {userExamples.map(example => this.renderExpression(example))}\n            </div>\n          ) : null}\n        </div>\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Combine stream selectors</div>\n          {this.renderExpression('{app=\"cassandra\",namespace=\"prod\"}')}\n          <div className=\"cheat-sheet-item__label\">Returns all log lines from streams that have both labels.</div>\n        </div>\n\n        <div className=\"cheat-sheet-item\">\n          <div className=\"cheat-sheet-item__title\">Filtering for search terms.</div>\n          {this.renderExpression('{app=\"cassandra\"} |~ \"(duration|latency)s*(=|is|of)s*[d.]+\"')}\n          {this.renderExpression('{app=\"cassandra\"} |= \"exact match\"')}\n          {this.renderExpression('{app=\"cassandra\"} != \"do not match\"')}\n          <div className=\"cheat-sheet-item__label\">\n            <a href=\"https://github.com/grafana/loki/blob/master/docs/logql.md#filter-expression\" target=\"logql\">\n              LogQL\n            </a>{' '}\n            supports exact and regular expression filters.\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { AbsoluteTimeRange } from '@grafana/data';\nimport { QueryEditorProps, DataSourceStatus } from '@grafana/ui';\nimport { LokiDatasource } from '../datasource';\nimport { LokiQuery } from '../types';\nimport { LokiQueryField } from './LokiQueryField';\nimport { useLokiSyntax } from './useLokiSyntax';\n\ntype Props = QueryEditorProps<LokiDatasource, LokiQuery>;\n\nexport const LokiQueryEditor = memo(function LokiQueryEditor(props: Props) {\n  const { query, panelData, datasource, onChange, onRunQuery } = props;\n\n  let absolute: AbsoluteTimeRange;\n  if (panelData && panelData.request) {\n    const { range } = panelData.request;\n    absolute = {\n      from: range.from.valueOf(),\n      to: range.to.valueOf(),\n    };\n  } else {\n    absolute = {\n      from: Date.now() - 10000,\n      to: Date.now(),\n    };\n  }\n\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider,\n    // TODO maybe use real status\n    DataSourceStatus.Connected,\n    absolute\n  );\n\n  return (\n    <div>\n      <LokiQueryField\n        datasource={datasource}\n        datasourceStatus={DataSourceStatus.Connected}\n        query={query}\n        onChange={onChange}\n        onRunQuery={onRunQuery}\n        history={[]}\n        panelData={panelData}\n        onLoadOptions={setActiveOption}\n        onLabelsRefresh={refreshLabels}\n        syntaxLoaded={isSyntaxReady}\n        absoluteRange={absolute}\n        {...syntaxProps}\n      />\n    </div>\n  );\n});\n\nexport default LokiQueryEditor;\n","import React, { FunctionComponent } from 'react';\nimport { LokiQueryFieldForm, LokiQueryFieldFormProps } from './LokiQueryFieldForm';\nimport { useLokiSyntax } from './useLokiSyntax';\nimport LokiLanguageProvider from '../language_provider';\n\nexport const LokiQueryField: FunctionComponent<LokiQueryFieldFormProps> = ({\n  datasource,\n  datasourceStatus,\n  ...otherProps\n}) => {\n  const { isSyntaxReady, setActiveOption, refreshLabels, ...syntaxProps } = useLokiSyntax(\n    datasource.languageProvider as LokiLanguageProvider,\n    datasourceStatus,\n    otherProps.absoluteRange\n  );\n\n  return (\n    <LokiQueryFieldForm\n      datasource={datasource}\n      datasourceStatus={datasourceStatus}\n      syntaxLoaded={isSyntaxReady}\n      /**\n       * setActiveOption name is intentional. Because of the way rc-cascader requests additional data\n       * https://github.com/react-component/cascader/blob/master/src/Cascader.jsx#L165\n       * we are notyfing useLokiSyntax hook, what the active option is, and then it's up to the hook logic\n       * to fetch data of options that aren't fetched yet\n       */\n      onLoadOptions={setActiveOption}\n      onLabelsRefresh={refreshLabels}\n      {...syntaxProps}\n      {...otherProps}\n    />\n  );\n};\n\nexport default LokiQueryField;\n","// Libraries\nimport _ from 'lodash';\n// Services & Utils\nimport {\n  dateMath,\n  DataFrame,\n  LogRowModel,\n  DateTime,\n  AnnotationEvent,\n  DataFrameView,\n  LoadingState,\n} from '@grafana/data';\nimport { addLabelToSelector } from 'app/plugins/datasource/prometheus/add_label_to_query';\nimport LanguageProvider from './language_provider';\nimport { logStreamToDataFrame } from './result_transformer';\nimport { formatQuery, parseQuery, getHighlighterExpressionsFromQuery } from './query_utils';\n// Types\nimport {\n  PluginMeta,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  AnnotationQueryRequest,\n} from '@grafana/ui';\n\nimport { LokiQuery, LokiOptions, LokiLogsStream, LokiResponse } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { safeStringifyValue, convertToWebSocketUrl } from 'app/core/utils/explore';\nimport { LiveTarget, LiveStreams } from './live_streams';\nimport { Observable, from, merge } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\n\nexport const DEFAULT_MAX_LINES = 1000;\n\nconst DEFAULT_QUERY_PARAMS = {\n  direction: 'BACKWARD',\n  limit: DEFAULT_MAX_LINES,\n  regexp: '',\n  query: '',\n};\n\nfunction serializeParams(data: any) {\n  return Object.keys(data)\n    .map(k => {\n      const v = data[k];\n      return encodeURIComponent(k) + '=' + encodeURIComponent(v);\n    })\n    .join('&');\n}\n\ninterface LokiContextQueryOptions {\n  direction?: 'BACKWARD' | 'FORWARD';\n  limit?: number;\n}\n\nexport class LokiDatasource extends DataSourceApi<LokiQuery, LokiOptions> {\n  private streams = new LiveStreams();\n  languageProvider: LanguageProvider;\n  maxLines: number;\n\n  /** @ngInject */\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<LokiOptions>,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.languageProvider = new LanguageProvider(this);\n    const settingsData = instanceSettings.jsonData || {};\n    this.maxLines = parseInt(settingsData.maxLines, 10) || DEFAULT_MAX_LINES;\n  }\n\n  _request(apiUrl: string, data?: any, options?: any) {\n    const baseUrl = this.instanceSettings.url;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}?${params}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return this.backendSrv.datasourceRequest(req);\n  }\n\n  prepareLiveTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>): LiveTarget {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const refId = target.refId;\n    const baseUrl = this.instanceSettings.url;\n    const params = serializeParams({ query, regexp });\n    const url = convertToWebSocketUrl(`${baseUrl}/api/prom/tail?${params}`);\n\n    return {\n      query,\n      regexp,\n      url,\n      refId,\n      size: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n    };\n  }\n\n  prepareQueryTarget(target: LokiQuery, options: DataQueryRequest<LokiQuery>) {\n    const interpolated = this.templateSrv.replace(target.expr);\n    const { query, regexp } = parseQuery(interpolated);\n    const start = this.getTime(options.range.from, false);\n    const end = this.getTime(options.range.to, true);\n    const refId = target.refId;\n    return {\n      ...DEFAULT_QUERY_PARAMS,\n      query,\n      regexp,\n      start,\n      end,\n      limit: Math.min(options.maxDataPoints || Infinity, this.maxLines),\n      refId,\n    };\n  }\n\n  processError = (err: any, target: any): DataQueryError => {\n    const error: DataQueryError = {\n      message: 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  processResult = (data: LokiLogsStream | LokiResponse, target: any): DataFrame[] => {\n    const series: DataFrame[] = [];\n\n    if (Object.keys(data).length === 0) {\n      return series;\n    }\n\n    if (!(data as any).streams) {\n      return [logStreamToDataFrame(data as LokiLogsStream, false, target.refId)];\n    }\n\n    data = data as LokiResponse;\n    for (const stream of data.streams || []) {\n      const dataFrame = logStreamToDataFrame(stream);\n      dataFrame.refId = target.refId;\n      dataFrame.meta = {\n        searchWords: getHighlighterExpressionsFromQuery(formatQuery(target.query, target.regexp)),\n        limit: this.maxLines,\n      };\n      series.push(dataFrame);\n    }\n\n    return series;\n  };\n\n  runLiveQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const liveTarget = this.prepareLiveTarget(target, options);\n    const stream = this.streams.getStream(liveTarget);\n    return stream.pipe(\n      map(data => {\n        return {\n          data,\n          key: `loki-${liveTarget.refId}`,\n          state: LoadingState.Streaming,\n        };\n      })\n    );\n  };\n\n  runQuery = (options: DataQueryRequest<LokiQuery>, target: LokiQuery): Observable<DataQueryResponse> => {\n    const query = this.prepareQueryTarget(target, options);\n    return from(\n      this._request('/api/prom/query', query).catch((err: any) => {\n        if (err.cancelled) {\n          return err;\n        }\n\n        const error: DataQueryError = this.processError(err, query);\n        throw error;\n      })\n    ).pipe(\n      filter((response: any) => (response.cancelled ? false : true)),\n      map((response: any) => {\n        const data = this.processResult(response.data, query);\n        return { data, key: query.refId };\n      })\n    );\n  };\n\n  query(options: DataQueryRequest<LokiQuery>): Observable<DataQueryResponse> {\n    const subQueries = options.targets\n      .filter(target => target.expr && !target.hide)\n      .map(target => {\n        if (target.liveStreaming) {\n          return this.runLiveQuery(options, target);\n        }\n        return this.runQuery(options, target);\n      });\n\n    return merge(...subQueries);\n  }\n\n  async importQueries(queries: LokiQuery[], originMeta: PluginMeta): Promise<LokiQuery[]> {\n    return this.languageProvider.importQueries(queries, originMeta.id);\n  }\n\n  metadataRequest(url: string, params?: any) {\n    // HACK to get label values for {job=|}, will be replaced when implementing LokiQueryField\n    const apiUrl = url.replace('v1', 'prom');\n    return this._request(apiUrl, params, { silent: true }).then((res: DataQueryResponse) => {\n      const data: any = { data: { data: res.data.values || [] } };\n      return data;\n    });\n  }\n\n  modifyQuery(query: LokiQuery, action: any): LokiQuery {\n    const parsed = parseQuery(query.expr || '');\n    let { query: selector } = parsed;\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        selector = addLabelToSelector(selector, action.key, action.value);\n        break;\n      }\n      default:\n        break;\n    }\n    const expression = formatQuery(selector, parsed.regexp);\n    return { ...query, expr: expression };\n  }\n\n  getHighlighterExpression(query: LokiQuery): string[] {\n    return getHighlighterExpressionsFromQuery(query.expr);\n  }\n\n  getTime(date: string | DateTime, roundUp: boolean) {\n    if (_.isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n    return Math.ceil(date.valueOf() * 1e6);\n  }\n\n  prepareLogRowContextQueryTarget = (row: LogRowModel, limit: number, direction: 'BACKWARD' | 'FORWARD') => {\n    const query = Object.keys(row.labels)\n      .map(label => {\n        return `${label}=\"${row.labels[label]}\"`;\n      })\n      .join(',');\n    const contextTimeBuffer = 2 * 60 * 60 * 1000 * 1e6; // 2h buffer\n    const timeEpochNs = row.timeEpochMs * 1e6;\n\n    const commontTargetOptons = {\n      limit,\n      query: `{${query}}`,\n      direction,\n    };\n\n    if (direction === 'BACKWARD') {\n      return {\n        ...commontTargetOptons,\n        start: timeEpochNs - contextTimeBuffer,\n        end: row.timestamp, // using RFC3339Nano format to avoid precision loss\n        direction,\n      };\n    } else {\n      return {\n        ...commontTargetOptons,\n        start: row.timestamp, // start param in Loki API is inclusive so we'll have to filter out the row that this request is based from\n        end: timeEpochNs + contextTimeBuffer,\n      };\n    }\n  };\n\n  getLogRowContext = async (row: LogRowModel, options?: LokiContextQueryOptions) => {\n    const target = this.prepareLogRowContextQueryTarget(\n      row,\n      (options && options.limit) || 10,\n      (options && options.direction) || 'BACKWARD'\n    );\n    const series: DataFrame[] = [];\n\n    try {\n      const reverse = options && options.direction === 'FORWARD';\n      const result = await this._request('/api/prom/query', target);\n      if (result.data) {\n        for (const stream of result.data.streams || []) {\n          series.push(logStreamToDataFrame(stream, reverse));\n        }\n      }\n\n      return {\n        data: series,\n      };\n    } catch (e) {\n      const error: DataQueryError = {\n        message: 'Error during context query. Please check JS console logs.',\n        status: e.status,\n        statusText: e.statusText,\n      };\n      throw error;\n    }\n  };\n\n  testDatasource() {\n    // Consider only last 10 minutes otherwise request takes too long\n    const startMs = Date.now() - 10 * 60 * 1000;\n    const start = `${startMs}000000`; // API expects nanoseconds\n    return this._request('/api/prom/label', { start })\n      .then((res: DataQueryResponse) => {\n        if (res && res.data && res.data.values && res.data.values.length > 0) {\n          return { status: 'success', message: 'Data source connected and labels found.' };\n        }\n        return {\n          status: 'error',\n          message:\n            'Data source connected, but no labels received. Verify that Loki and Promtail is configured properly.',\n        };\n      })\n      .catch((err: any) => {\n        let message = 'Loki: ';\n        if (err.statusText) {\n          message += err.statusText;\n        } else {\n          message += 'Cannot connect to Loki';\n        }\n\n        if (err.status) {\n          message += `. ${err.status}`;\n        }\n\n        if (err.data && err.data.message) {\n          message += `. ${err.data.message}`;\n        } else if (err.data) {\n          message += `. ${err.data}`;\n        }\n        return { status: 'error', message: message };\n      });\n  }\n\n  async annotationQuery(options: AnnotationQueryRequest<LokiQuery>): Promise<AnnotationEvent[]> {\n    if (!options.annotation.expr) {\n      return [];\n    }\n\n    const request = queryRequestFromAnnotationOptions(options);\n    const { data } = await this.runQuery(request, request.targets[0]).toPromise();\n    const annotations: AnnotationEvent[] = [];\n\n    for (const frame of data) {\n      const tags = Object.values(frame.labels) as string[];\n      const view = new DataFrameView<{ ts: string; line: string }>(frame);\n\n      view.forEachRow(row => {\n        annotations.push({\n          time: new Date(row.ts).valueOf(),\n          text: row.line,\n          tags,\n        });\n      });\n    }\n\n    return annotations;\n  }\n}\n\nfunction queryRequestFromAnnotationOptions(options: AnnotationQueryRequest<LokiQuery>): DataQueryRequest<LokiQuery> {\n  const refId = `annotation-${options.annotation.name}`;\n  const target: LokiQuery = { refId, expr: options.annotation.expr };\n\n  return {\n    requestId: refId,\n    range: options.range,\n    targets: [target],\n    dashboardId: options.dashboard.id,\n    scopedVars: null,\n    startTime: Date.now(),\n\n    // This should mean the default defined on datasource is used.\n    maxDataPoints: 0,\n\n    // Dummy values, are required in type but not used here.\n    timezone: 'utc',\n    panelId: 0,\n    interval: '',\n    intervalMs: 0,\n  };\n}\n\nexport default LokiDatasource;\n","// Libraries\nimport _ from 'lodash';\n\n// Services & Utils\nimport { parseSelector, labelRegexp, selectorRegexp } from 'app/plugins/datasource/prometheus/language_utils';\nimport syntax from './syntax';\n\n// Types\nimport { CompletionItem, LanguageProvider, TypeaheadInput, TypeaheadOutput, HistoryItem } from 'app/types/explore';\nimport { LokiQuery } from './types';\nimport { dateTime, AbsoluteTimeRange } from '@grafana/data';\nimport { PromQuery } from '../prometheus/types';\n\nimport LokiDatasource from './datasource';\n\nconst DEFAULT_KEYS = ['job', 'namespace'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 10;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nconst NS_IN_MS = 1000000;\nexport const LABEL_REFRESH_INTERVAL = 1000 * 30; // 30sec\n\nconst wrapLabel = (label: string) => ({ label });\nexport const rangeToParams = (range: AbsoluteTimeRange) => ({ start: range.from * NS_IN_MS, end: range.to * NS_IN_MS });\n\nexport type LokiHistoryItem = HistoryItem<LokiQuery>;\n\ntype TypeaheadContext = {\n  history?: LokiHistoryItem[];\n  absoluteRange?: AbsoluteTimeRange;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: LokiHistoryItem[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && (h.query.expr as string) === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nexport default class LokiLanguageProvider extends LanguageProvider {\n  labelKeys?: { [index: string]: string[] }; // metric -> [labelKey,...]\n  labelValues?: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\n  logLabelOptions: any[];\n  logLabelFetchTs?: number;\n  started: boolean;\n  initialRange: AbsoluteTimeRange;\n  datasource: LokiDatasource;\n\n  constructor(datasource: LokiDatasource, initialValues?: any) {\n    super();\n\n    this.datasource = datasource;\n    this.labelKeys = {};\n    this.labelValues = {};\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars\n  cleanText = (s: string) => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n\n  getSyntax() {\n    return syntax;\n  }\n\n  request = (url: string, params?: any) => {\n    return this.datasource.metadataRequest(url, params);\n  };\n\n  /**\n   * Initialise the language provider by fetching set of labels. Without this initialisation the provider would return\n   * just a set of hardcoded default labels on provideCompletionItems or a recent queries from history.\n   */\n  start = () => {\n    if (!this.startTask) {\n      this.startTask = this.fetchLogLabels(this.initialRange).then(() => {\n        this.started = true;\n        return [];\n      });\n    }\n    return this.startTask;\n  };\n\n  getLabelKeys(): string[] {\n    return this.labelKeys[EMPTY_SELECTOR];\n  }\n\n  async getLabelValues(key: string): Promise<string[]> {\n    await this.fetchLabelValues(key, this.initialRange);\n    return this.labelValues[EMPTY_SELECTOR][key];\n  }\n\n  /**\n   * Return suggestions based on input that can be then plugged into a typeahead dropdown.\n   * Keep this DOM-free for testing\n   * @param input\n   * @param context Is optional in types but is required in case we are doing getLabelCompletionItems\n   * @param context.absoluteRange Required in case we are doing getLabelCompletionItems\n   * @param context.history Optional used only in getEmptyCompletionItems\n   */\n  async provideCompletionItems(input: TypeaheadInput, context?: TypeaheadContext): Promise<TypeaheadOutput> {\n    const { wrapperClasses, value } = input;\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    // Determine candidates by CSS context\n    if (_.includes(wrapperClasses, 'context-labels')) {\n      // Suggestions for {|} and {foo=|}\n      return await this.getLabelCompletionItems(input, context);\n    } else if (empty) {\n      return this.getEmptyCompletionItems(context || {});\n    }\n\n    return {\n      suggestions: [],\n    };\n  }\n\n  getEmptyCompletionItems(context: any): TypeaheadOutput {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length > 0) {\n      const historyItems = _.chain(history)\n        .map((h: any) => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map((item: CompletionItem) => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  }\n\n  async getLabelCompletionItems(\n    { text, wrapperClasses, labelKey, value }: TypeaheadInput,\n    { absoluteRange }: any\n  ): Promise<TypeaheadOutput> {\n    let context: string;\n    const suggestions = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset: number = value.selection.anchor.offset;\n\n    // Use EMPTY_SELECTOR until series API is implemented for facetting\n    const selector = EMPTY_SELECTOR;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n    } catch {}\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    if ((text && text.match(/^!?=~?/)) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && this.labelValues[selector]) {\n        let labelValues = this.labelValues[selector][labelKey];\n        if (!labelValues) {\n          await this.fetchLabelValues(labelKey, absoluteRange);\n          labelValues = this.labelValues[selector][labelKey];\n        }\n\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues.map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = this.labelKeys[selector] || DEFAULT_KEYS;\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length > 0) {\n          context = 'context-labels';\n          suggestions.push({ label: `Labels`, items: possibleKeys.map(wrapLabel) });\n        }\n      }\n    }\n\n    return { context, suggestions };\n  }\n\n  async importQueries(queries: LokiQuery[], datasourceType: string): Promise<LokiQuery[]> {\n    if (datasourceType === 'prometheus') {\n      return Promise.all(\n        queries.map(async query => {\n          const expr = await this.importPrometheusQuery(query.expr);\n          const { context, ...rest } = query as PromQuery;\n          return {\n            ...rest,\n            expr,\n          };\n        })\n      );\n    }\n    // Return a cleaned LokiQuery\n    return queries.map(query => ({\n      refId: query.refId,\n      expr: '',\n    }));\n  }\n\n  async importPrometheusQuery(query: string): Promise<string> {\n    if (!query) {\n      return '';\n    }\n\n    // Consider only first selector in query\n    const selectorMatch = query.match(selectorRegexp);\n    if (selectorMatch) {\n      const selector = selectorMatch[0];\n      const labels: { [key: string]: { value: any; operator: any } } = {};\n      selector.replace(labelRegexp, (_, key, operator, value) => {\n        labels[key] = { value, operator };\n        return '';\n      });\n\n      // Keep only labels that exist on origin and target datasource\n      await this.start(); // fetches all existing label keys\n      const existingKeys = this.labelKeys[EMPTY_SELECTOR];\n      let labelsToKeep: { [key: string]: { value: any; operator: any } } = {};\n      if (existingKeys && existingKeys.length > 0) {\n        // Check for common labels\n        for (const key in labels) {\n          if (existingKeys && existingKeys.includes(key)) {\n            // Should we check for label value equality here?\n            labelsToKeep[key] = labels[key];\n          }\n        }\n      } else {\n        // Keep all labels by default\n        labelsToKeep = labels;\n      }\n\n      const labelKeys = Object.keys(labelsToKeep).sort();\n      const cleanSelector = labelKeys\n        .map(key => `${key}${labelsToKeep[key].operator}${labelsToKeep[key].value}`)\n        .join(',');\n\n      return ['{', cleanSelector, '}'].join('');\n    }\n\n    return '';\n  }\n\n  async fetchLogLabels(absoluteRange: AbsoluteTimeRange): Promise<any> {\n    const url = '/api/prom/label';\n    try {\n      this.logLabelFetchTs = Date.now();\n\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const labelKeys = body.data.slice().sort();\n      this.labelKeys = {\n        ...this.labelKeys,\n        [EMPTY_SELECTOR]: labelKeys,\n      };\n      this.labelValues = {\n        [EMPTY_SELECTOR]: {},\n      };\n      this.logLabelOptions = labelKeys.map((key: string) => ({ label: key, value: key, isLeaf: false }));\n    } catch (e) {\n      console.error(e);\n    }\n    return [];\n  }\n\n  async refreshLogLabels(absoluteRange: AbsoluteTimeRange, forceRefresh?: boolean) {\n    if ((this.labelKeys && Date.now() - this.logLabelFetchTs > LABEL_REFRESH_INTERVAL) || forceRefresh) {\n      await this.fetchLogLabels(absoluteRange);\n    }\n  }\n\n  async fetchLabelValues(key: string, absoluteRange: AbsoluteTimeRange) {\n    const url = `/api/prom/label/${key}/values`;\n    try {\n      const res = await this.request(url, rangeToParams(absoluteRange));\n      const body = await (res.data || res.json());\n      const values = body.data.slice().sort();\n\n      // Add to label options\n      this.logLabelOptions = this.logLabelOptions.map(keyOption => {\n        if (keyOption.value === key) {\n          return {\n            ...keyOption,\n            children: values.map((value: string) => ({ label: value, value })),\n          };\n        }\n        return keyOption;\n      });\n\n      // Add to key map\n      const exisingValues = this.labelValues[EMPTY_SELECTOR];\n      const nextValues = {\n        ...exisingValues,\n        [key]: values,\n      };\n      this.labelValues = {\n        ...this.labelValues,\n        [EMPTY_SELECTOR]: nextValues,\n      };\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n","import { DataFrame, FieldType, parseLabels, KeyValue, CircularDataFrame } from '@grafana/data';\nimport { Observable } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nimport { LokiResponse } from './types';\nimport { finalize, map } from 'rxjs/operators';\nimport { appendResponseToBufferedData } from './result_transformer';\n\n/**\n * Maps directly to a query in the UI (refId is key)\n */\nexport interface LiveTarget {\n  query: string;\n  regexp: string;\n  url: string;\n  refId: string;\n  size: number;\n}\n\n/**\n * Cache of websocket streams that can be returned as observable. In case there already is a stream for particular\n * target it is returned and on subscription returns the latest dataFrame.\n */\nexport class LiveStreams {\n  private streams: KeyValue<Observable<DataFrame[]>> = {};\n\n  getStream(target: LiveTarget): Observable<DataFrame[]> {\n    let stream = this.streams[target.url];\n    if (!stream) {\n      const data = new CircularDataFrame({ capacity: target.size });\n      data.labels = parseLabels(target.query);\n      data.addField({ name: 'ts', type: FieldType.time, config: { title: 'Time' } });\n      data.addField({ name: 'line', type: FieldType.string });\n      data.addField({ name: 'labels', type: FieldType.other });\n\n      stream = webSocket(target.url).pipe(\n        finalize(() => {\n          delete this.streams[target.url];\n        }),\n        map((response: LokiResponse) => {\n          appendResponseToBufferedData(response, data);\n          return [data];\n        })\n      );\n      this.streams[target.url] = stream;\n    }\n    return stream;\n  }\n}\n","import Datasource from './datasource';\n\nimport LokiCheatSheet from './components/LokiCheatSheet';\nimport LokiQueryField from './components/LokiQueryField';\nimport LokiQueryEditor from './components/LokiQueryEditor';\nimport { LokiAnnotationsQueryCtrl } from './LokiAnnotationsQueryCtrl';\n\nexport class LokiConfigCtrl {\n  static templateUrl = 'partials/config.html';\n}\n\nexport {\n  Datasource,\n  LokiQueryEditor as QueryEditor,\n  LokiConfigCtrl as ConfigCtrl,\n  LokiQueryField as ExploreQueryField,\n  LokiCheatSheet as ExploreStartPage,\n  LokiAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n};\n","import { LokiExpression } from './types';\n\nconst selectorRegexp = /(?:^|\\s){[^{]*}/g;\nconst caseInsensitive = '(?i)'; // Golang mode modifier for Loki, doesn't work in JavaScript\nexport function parseQuery(input: string): LokiExpression {\n  input = input || '';\n  const match = input.match(selectorRegexp);\n  let query = input;\n  let regexp = '';\n\n  if (match) {\n    regexp = input.replace(selectorRegexp, '').trim();\n    // Keep old-style regexp, otherwise take whole query\n    if (regexp && regexp.search(/\\|=|\\|~|!=|!~/) === -1) {\n      query = match[0].trim();\n      if (!regexp.startsWith(caseInsensitive)) {\n        regexp = `${caseInsensitive}${regexp}`;\n      }\n    } else {\n      regexp = '';\n    }\n  }\n\n  return { regexp, query };\n}\n\nexport function formatQuery(selector: string, search: string): string {\n  return `${selector || ''} ${search || ''}`.trim();\n}\n\n/**\n * Returns search terms from a LogQL query.\n * E.g., `{} |= foo |=bar != baz` returns `['foo', 'bar']`.\n */\nexport function getHighlighterExpressionsFromQuery(input: string): string[] {\n  const parsed = parseQuery(input);\n  // Legacy syntax\n  if (parsed.regexp) {\n    return [parsed.regexp];\n  }\n  let expression = input;\n  const results = [];\n  // Consume filter expression from left to right\n  while (expression) {\n    const filterStart = expression.search(/\\|=|\\|~|!=|!~/);\n    // Nothing more to search\n    if (filterStart === -1) {\n      break;\n    }\n    // Drop terms for negative filters\n    const skip = expression.substr(filterStart).search(/!=|!~/) === 0;\n    expression = expression.substr(filterStart + 2);\n    if (skip) {\n      continue;\n    }\n    // Check if there is more chained\n    const filterEnd = expression.search(/\\|=|\\|~|!=|!~/);\n    let filterTerm;\n    if (filterEnd === -1) {\n      filterTerm = expression.trim();\n    } else {\n      filterTerm = expression.substr(0, filterEnd).trim();\n      expression = expression.substr(filterEnd);\n    }\n\n    // Unwrap the filter term by removing quotes\n    const quotedTerm = filterTerm.match(/^\"((?:[^\\\\\"]|\\\\\")*)\"$/);\n\n    if (quotedTerm) {\n      const unwrappedFilterTerm = quotedTerm[1];\n      results.push(unwrappedFilterTerm);\n    } else {\n      return null;\n    }\n  }\n  return results;\n}\n","import { LokiLogsStream, LokiResponse } from './types';\nimport {\n  parseLabels,\n  FieldType,\n  Labels,\n  DataFrame,\n  ArrayVector,\n  MutableDataFrame,\n  findUniqueLabels,\n} from '@grafana/data';\n\n/**\n * Transforms LokiLogStream structure into a dataFrame. Used when doing standard queries.\n */\nexport function logStreamToDataFrame(stream: LokiLogsStream, reverse?: boolean, refId?: string): DataFrame {\n  let labels: Labels = stream.parsedLabels;\n  if (!labels && stream.labels) {\n    labels = parseLabels(stream.labels);\n  }\n  const times = new ArrayVector<string>([]);\n  const lines = new ArrayVector<string>([]);\n\n  for (const entry of stream.entries) {\n    times.add(entry.ts || entry.timestamp);\n    lines.add(entry.line);\n  }\n\n  if (reverse) {\n    times.buffer = times.buffer.reverse();\n    lines.buffer = lines.buffer.reverse();\n  }\n\n  return {\n    refId,\n    labels,\n    fields: [\n      { name: 'ts', type: FieldType.time, config: { title: 'Time' }, values: times }, // Time\n      { name: 'line', type: FieldType.string, config: {}, values: lines }, // Line\n    ],\n    length: times.length,\n  };\n}\n\n/**\n * Transform LokiResponse data and appends it to MutableDataFrame. Used for streaming where the dataFrame can be\n * a CircularDataFrame creating a fixed size rolling buffer.\n * TODO: Probably could be unified with the logStreamToDataFrame function.\n */\nexport function appendResponseToBufferedData(response: LokiResponse, data: MutableDataFrame) {\n  // Should we do anythign with: response.dropped_entries?\n\n  const streams: LokiLogsStream[] = response.streams;\n  if (streams && streams.length) {\n    for (const stream of streams) {\n      // Find unique labels\n      const labels = parseLabels(stream.labels);\n      const unique = findUniqueLabels(labels, data.labels);\n\n      // Add each line\n      for (const entry of stream.entries) {\n        data.values.ts.add(entry.ts || entry.timestamp);\n        data.values.line.add(entry.line);\n        data.values.labels.add(unique);\n      }\n    }\n  }\n}\n","import { Grammar } from 'prismjs';\n\n/* tslint:disable max-line-length */\n\nconst tokenizer: Grammar = {\n  comment: {\n    pattern: /(^|[^\\n])#.*/,\n    lookbehind: true,\n  },\n  'context-labels': {\n    pattern: /(^|\\s)\\{[^}]*(?=})/,\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n      punctuation: /[{]/,\n    },\n  },\n  // number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?`, 'i'),\n  punctuation: /[{}`,.]/,\n};\n\nexport default tokenizer;\n","import _ from 'lodash';\n\nconst keywords = 'by|without|on|ignoring|group_left|group_right|bool|or|and|unless';\n\n// Duplicate from mode-prometheus.js, which can't be used in tests due to global ace not being loaded.\nconst builtInWords = [\n  keywords,\n  'count|count_values|min|max|avg|sum|stddev|stdvar|bottomk|topk|quantile',\n  'true|false|null|__name__|job',\n  'abs|absent|ceil|changes|clamp_max|clamp_min|count_scalar|day_of_month|day_of_week|days_in_month|delta|deriv',\n  'drop_common_labels|exp|floor|histogram_quantile|holt_winters|hour|idelta|increase|irate|label_replace|ln|log2',\n  'log10|minute|month|predict_linear|rate|resets|round|scalar|sort|sort_desc|sqrt|time|vector|year|avg_over_time',\n  'min_over_time|max_over_time|sum_over_time|count_over_time|quantile_over_time|stddev_over_time|stdvar_over_time',\n]\n  .join('|')\n  .split('|');\n\nconst metricNameRegexp = /([A-Za-z:][\\w:]*)\\b(?![\\(\\]{=!\",])/g;\nconst selectorRegexp = /{([^{]*)}/g;\n\n// addLabelToQuery('foo', 'bar', 'baz') => 'foo{bar=\"baz\"}'\nexport function addLabelToQuery(query: string, key: string, value: string, operator?: string): string {\n  if (!key || !value) {\n    throw new Error('Need label to add to query.');\n  }\n\n  // Add empty selectors to bare metric names\n  let previousWord: string;\n  query = query.replace(metricNameRegexp, (match, word, offset) => {\n    const insideSelector = isPositionInsideChars(query, offset, '{', '}');\n    // Handle \"sum by (key) (metric)\"\n    const previousWordIsKeyWord = previousWord && keywords.split('|').indexOf(previousWord) > -1;\n\n    // check for colon as as \"word boundary\" symbol\n    const isColonBounded = word.endsWith(':');\n\n    previousWord = word;\n    if (!insideSelector && !isColonBounded && !previousWordIsKeyWord && builtInWords.indexOf(word) === -1) {\n      return `${word}{}`;\n    }\n    return word;\n  });\n\n  // Adding label to existing selectors\n  let match = selectorRegexp.exec(query);\n  const parts = [];\n  let lastIndex = 0;\n  let suffix = '';\n\n  while (match) {\n    const prefix = query.slice(lastIndex, match.index);\n    const selector = match[1];\n    const selectorWithLabel = addLabelToSelector(selector, key, value, operator);\n    lastIndex = match.index + match[1].length + 2;\n    suffix = query.slice(match.index + match[0].length);\n    parts.push(prefix, selectorWithLabel);\n    match = selectorRegexp.exec(query);\n  }\n\n  parts.push(suffix);\n  return parts.join('');\n}\n\nconst labelRegexp = /(\\w+)\\s*(=|!=|=~|!~)\\s*(\"[^\"]*\")/g;\n\nexport function addLabelToSelector(selector: string, labelKey: string, labelValue: string, labelOperator?: string) {\n  const parsedLabels = [];\n\n  // Split selector into labels\n  if (selector) {\n    let match = labelRegexp.exec(selector);\n    while (match) {\n      parsedLabels.push({ key: match[1], operator: match[2], value: match[3] });\n      match = labelRegexp.exec(selector);\n    }\n  }\n\n  // Add new label\n  const operatorForLabelKey = labelOperator || '=';\n  parsedLabels.push({ key: labelKey, operator: operatorForLabelKey, value: `\"${labelValue}\"` });\n\n  // Sort labels by key and put them together\n  const formatted = _.chain(parsedLabels)\n    .uniqWith(_.isEqual)\n    .compact()\n    .sortBy('key')\n    .map(({ key, operator, value }) => `${key}${operator}${value}`)\n    .value()\n    .join(',');\n\n  return `{${formatted}}`;\n}\n\nfunction isPositionInsideChars(text: string, position: number, openChar: string, closeChar: string) {\n  const nextSelectorStart = text.slice(position).indexOf(openChar);\n  const nextSelectorEnd = text.slice(position).indexOf(closeChar);\n  return nextSelectorEnd > -1 && (nextSelectorStart === -1 || nextSelectorStart > nextSelectorEnd);\n}\n\nexport default addLabelToQuery;\n","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport const processHistogramLabels = (labels: string[]) => {\n  const result = [];\n  const regexp = new RegExp('_bucket($|:)');\n  for (let index = 0; index < labels.length; index++) {\n    const label = labels[index];\n    const isHistogramValue = regexp.test(label);\n    if (isHistogramValue) {\n      if (result.indexOf(label) === -1) {\n        result.push(label);\n      }\n    }\n  }\n\n  return { values: { __name__: result } };\n};\n\nexport function processLabels(labels: Array<{ [key: string]: string }>, withName = false) {\n  const values: { [key: string]: string[] } = {};\n  labels.forEach(l => {\n    const { __name__, ...rest } = l;\n    if (withName) {\n      values['__name__'] = values['__name__'] || [];\n      if (!values['__name__'].includes(__name__)) {\n        values['__name__'].push(__name__);\n      }\n    }\n\n    Object.keys(rest).forEach(key => {\n      if (!values[key]) {\n        values[key] = [];\n      }\n      if (!values[key].includes(rest[key])) {\n        values[key].push(rest[key]);\n      }\n    });\n  });\n  return { values, keys: Object.keys(values) };\n}\n\n// const cleanSelectorRegexp = /\\{(\\w+=\"[^\"\\n]*?\")(,\\w+=\"[^\"\\n]*?\")*\\}/;\nexport const selectorRegexp = /\\{[^}]*?\\}/;\nexport const labelRegexp = /\\b(\\w+)(!?=~?)(\"[^\"\\n]*?\")/g;\nexport function parseSelector(query: string, cursorOffset = 1): { labelKeys: any[]; selector: string } {\n  if (!query.match(selectorRegexp)) {\n    // Special matcher for metrics\n    if (query.match(/^[A-Za-z:][\\w:]*$/)) {\n      return {\n        selector: `{__name__=\"${query}\"}`,\n        labelKeys: ['__name__'],\n      };\n    }\n    throw new Error('Query must contain a selector: ' + query);\n  }\n\n  // Check if inside a selector\n  const prefix = query.slice(0, cursorOffset);\n  const prefixOpen = prefix.lastIndexOf('{');\n  const prefixClose = prefix.lastIndexOf('}');\n  if (prefixOpen === -1) {\n    throw new Error('Not inside selector, missing open brace: ' + prefix);\n  }\n  if (prefixClose > -1 && prefixClose > prefixOpen) {\n    throw new Error('Not inside selector, previous selector already closed: ' + prefix);\n  }\n  const suffix = query.slice(cursorOffset);\n  const suffixCloseIndex = suffix.indexOf('}');\n  const suffixClose = suffixCloseIndex + cursorOffset;\n  const suffixOpenIndex = suffix.indexOf('{');\n  const suffixOpen = suffixOpenIndex + cursorOffset;\n  if (suffixClose === -1) {\n    throw new Error('Not inside selector, missing closing brace in suffix: ' + suffix);\n  }\n  if (suffixOpenIndex > -1 && suffixOpen < suffixClose) {\n    throw new Error('Not inside selector, next selector opens before this one closed: ' + suffix);\n  }\n\n  // Extract clean labels to form clean selector, incomplete labels are dropped\n  const selector = query.slice(prefixOpen, suffixClose);\n  const labels: { [key: string]: { value: string; operator: string } } = {};\n  selector.replace(labelRegexp, (_, key, operator, value) => {\n    labels[key] = { value, operator };\n    return '';\n  });\n\n  // Add metric if there is one before the selector\n  const metricPrefix = query.slice(0, prefixOpen);\n  const metricMatch = metricPrefix.match(/[A-Za-z:][\\w:]*$/);\n  if (metricMatch) {\n    labels['__name__'] = { value: `\"${metricMatch[0]}\"`, operator: '=' };\n  }\n\n  // Build sorted selector\n  const labelKeys = Object.keys(labels).sort();\n  const cleanSelector = labelKeys.map(key => `${key}${labels[key].operator}${labels[key].value}`).join(',');\n\n  const selectorString = ['{', cleanSelector, '}'].join('');\n\n  return { labelKeys, selector: selectorString };\n}\n\nexport function expandRecordingRules(query: string, mapping: { [name: string]: string }): string {\n  const ruleNames = Object.keys(mapping);\n  const rulesRegex = new RegExp(`(\\\\s|^)(${ruleNames.join('|')})(\\\\s|$|\\\\(|\\\\[|\\\\{)`, 'ig');\n  return query.replace(rulesRegex, (match, pre, name, post) => `${pre}${mapping[name]}${post}`);\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAXA;AAYA;AAAA;AAbA;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AAIA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAcA;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AACA;;;;AAGA;;;;;AAEA;;AAyDA;AArFA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAoBA;AACA;AAEA;AAMA;AAGA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;ACpGA;AACA;AAIA;AAGA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAKA;AAEA;AAEA;AAgBA;AAEA;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AAGA;AACA;AAIA;AAMA;AAKA;;;;;AAKA;AACA;AAMA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAAA;AAKA;AACA;AAAA;AACA;AACA;AACA;AARA;AA8DA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AAAA;AACA;AAKA;AACA;AAEA;;;;;;AACA;AAKA;;;;AAGA;AACA;;AAAA;AACA;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AAEA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;AArPA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AAqFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;;AACA;;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA+DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;;;;;AACA;AACA;AACA;AAEA;AACA;;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAVA;AAAA;AAAA;AAWA;;;;;;;;;AAEA;;;;AACA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AClZA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAAA;AASA;AAAA;AAUA;AACA;AAMA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AACA;AACA;AAEA;;AACA;AAKA;AACA;AACA;AAoBA;AACA;AACA;AAEA;AAAA;;;AACA;;AAAA;AACA;;;;AACA;AAEA;;;;;;;AAOA;AACA;AAAA;;;;;AACA;AAEA;AAEA;AAEA;;AADA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;;;;AACA;AAEA;AAAA;;;AACA;AACA;;;;AAEA;;AAAA;AACA;AACA;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AAAA;;;;;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;;;;AACA;AAEA;AAAA;;;;;;AACA;;;;AAEA;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;AAEA;;AAEA;;;;AACA;AAEA;;;;;AACA;AACA;;AAAA;;;;;;AAEA;AAEA;;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AAIA;;;;AAKA;;;;;;AAEA;AACA;AAAA;;;;;;;;;;;;;;ACjUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAaA;;;AAGA;AACA;AAAA;AACA;AAwBA;AAtBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAFA;AAIA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3EA;AAUA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;;AAEA;AACA;;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;;;;;;;;;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;ACnGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}