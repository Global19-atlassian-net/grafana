{"version":3,"file":"cloudwatchPlugin.fb2366366adbbbf1d38b.js","sources":["webpack:///webpack:///./public/app/plugins/datasource/cloudwatch/config_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/cloudwatch/datasource.ts","webpack:///webpack:///./public/app/plugins/datasource/cloudwatch/module.ts","webpack:///webpack:///./public/app/plugins/datasource/cloudwatch/query_ctrl.ts","webpack:///webpack:///./public/app/plugins/datasource/cloudwatch/query_parameter_ctrl.ts"],"sourcesContent":["import _ from 'lodash';\nimport DatasourceSrv from 'app/features/plugins/datasource_srv';\nimport CloudWatchDatasource from './datasource';\nexport class CloudWatchConfigCtrl {\n  static templateUrl = 'partials/config.html';\n  current: any;\n  datasourceSrv: any;\n\n  accessKeyExist = false;\n  secretKeyExist = false;\n\n  /** @ngInject */\n  constructor($scope: any, datasourceSrv: DatasourceSrv) {\n    this.current.jsonData.timeField = this.current.jsonData.timeField || '@timestamp';\n    this.current.jsonData.authType = this.current.jsonData.authType || 'credentials';\n\n    this.accessKeyExist = this.current.secureJsonFields.accessKey;\n    this.secretKeyExist = this.current.secureJsonFields.secretKey;\n    this.datasourceSrv = datasourceSrv;\n    this.getRegions();\n  }\n\n  resetAccessKey() {\n    this.accessKeyExist = false;\n  }\n\n  resetSecretKey() {\n    this.secretKeyExist = false;\n  }\n\n  authTypes = [\n    { name: 'Access & secret key', value: 'keys' },\n    { name: 'Credentials file', value: 'credentials' },\n    { name: 'ARN', value: 'arn' },\n  ];\n\n  indexPatternTypes: any = [\n    { name: 'No pattern', value: undefined },\n    { name: 'Hourly', value: 'Hourly', example: '[logstash-]YYYY.MM.DD.HH' },\n    { name: 'Daily', value: 'Daily', example: '[logstash-]YYYY.MM.DD' },\n    { name: 'Weekly', value: 'Weekly', example: '[logstash-]GGGG.WW' },\n    { name: 'Monthly', value: 'Monthly', example: '[logstash-]YYYY.MM' },\n    { name: 'Yearly', value: 'Yearly', example: '[logstash-]YYYY' },\n  ];\n\n  regions = [\n    'ap-northeast-1',\n    'ap-northeast-2',\n    'ap-northeast-3',\n    'ap-south-1',\n    'ap-southeast-1',\n    'ap-southeast-2',\n    'ca-central-1',\n    'cn-north-1',\n    'cn-northwest-1',\n    'eu-central-1',\n    'eu-north-1',\n    'eu-west-1',\n    'eu-west-2',\n    'eu-west-3',\n    'me-south-1',\n    'sa-east-1',\n    'us-east-1',\n    'us-east-2',\n    'us-gov-east-1',\n    'us-gov-west-1',\n    'us-iso-east-1',\n    'us-isob-east-1',\n    'us-west-1',\n    'us-west-2',\n  ];\n\n  getRegions() {\n    this.datasourceSrv\n      .loadDatasource(this.current.name)\n      .then((ds: CloudWatchDatasource) => {\n        return ds.getRegions();\n      })\n      .then(\n        (regions: any) => {\n          this.regions = _.map(regions, 'value');\n        },\n        (err: any) => {\n          console.error('failed to get latest regions');\n        }\n      );\n  }\n}\n","import angular, { IQService } from 'angular';\nimport _ from 'lodash';\nimport { dateMath, ScopedVars } from '@grafana/data';\nimport kbn from 'app/core/utils/kbn';\nimport { CloudWatchQuery } from './types';\nimport { DataSourceApi, DataQueryRequest, DataSourceInstanceSettings } from '@grafana/ui';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\n// import * as moment from 'moment';\n\nexport default class CloudWatchDatasource extends DataSourceApi<CloudWatchQuery> {\n  type: any;\n  proxyUrl: any;\n  defaultRegion: any;\n  standardStatistics: any;\n\n  /** @ngInject */\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv,\n    private timeSrv: TimeSrv\n  ) {\n    super(instanceSettings);\n    this.type = 'cloudwatch';\n    this.proxyUrl = instanceSettings.url;\n    this.defaultRegion = instanceSettings.jsonData.defaultRegion;\n    this.instanceSettings = instanceSettings;\n    this.standardStatistics = ['Average', 'Maximum', 'Minimum', 'Sum', 'SampleCount'];\n  }\n\n  query(options: DataQueryRequest<CloudWatchQuery>) {\n    options = angular.copy(options);\n    options.targets = this.expandTemplateVariable(options.targets, options.scopedVars, this.templateSrv);\n\n    const queries = _.filter(options.targets, item => {\n      return (\n        (item.id !== '' || item.hide !== true) &&\n        ((!!item.region && !!item.namespace && !!item.metricName && !_.isEmpty(item.statistics)) ||\n          item.expression.length > 0)\n      );\n    }).map(item => {\n      item.region = this.templateSrv.replace(this.getActualRegion(item.region), options.scopedVars);\n      item.namespace = this.templateSrv.replace(item.namespace, options.scopedVars);\n      item.metricName = this.templateSrv.replace(item.metricName, options.scopedVars);\n      item.dimensions = this.convertDimensionFormat(item.dimensions, options.scopedVars);\n      item.statistics = item.statistics.map(s => {\n        return this.templateSrv.replace(s, options.scopedVars);\n      });\n      item.period = String(this.getPeriod(item, options)); // use string format for period in graph query, and alerting\n      item.id = this.templateSrv.replace(item.id, options.scopedVars);\n      item.expression = this.templateSrv.replace(item.expression, options.scopedVars);\n\n      // valid ExtendedStatistics is like p90.00, check the pattern\n      const hasInvalidStatistics = item.statistics.some(s => {\n        if (s.indexOf('p') === 0) {\n          const matches = /^p\\d{2}(?:\\.\\d{1,2})?$/.exec(s);\n          return !matches || matches[0] !== s;\n        }\n\n        return false;\n      });\n\n      if (hasInvalidStatistics) {\n        throw { message: 'Invalid extended statistics' };\n      }\n\n      return _.extend(\n        {\n          refId: item.refId,\n          intervalMs: options.intervalMs,\n          maxDataPoints: options.maxDataPoints,\n          datasourceId: this.instanceSettings.id,\n          type: 'timeSeriesQuery',\n        },\n        item\n      );\n    });\n\n    // No valid targets, return the empty result to save a round trip.\n    if (_.isEmpty(queries)) {\n      const d = this.$q.defer();\n      d.resolve({ data: [] });\n      return d.promise;\n    }\n\n    const request = {\n      from: options.range.from.valueOf().toString(),\n      to: options.range.to.valueOf().toString(),\n      queries: queries,\n    };\n\n    return this.performTimeSeriesQuery(request);\n  }\n\n  getPeriod(target: any, options: any, now?: number) {\n    const start = this.convertToCloudWatchTime(options.range.from, false);\n    const end = this.convertToCloudWatchTime(options.range.to, true);\n    now = Math.round((now || Date.now()) / 1000);\n\n    let period;\n    const range = end - start;\n\n    const hourSec = 60 * 60;\n    const daySec = hourSec * 24;\n    let periodUnit = 60;\n    if (!target.period) {\n      if (now - start <= daySec * 15) {\n        // until 15 days ago\n        if (target.namespace === 'AWS/EC2') {\n          periodUnit = period = 300;\n        } else {\n          periodUnit = period = 60;\n        }\n      } else if (now - start <= daySec * 63) {\n        // until 63 days ago\n        periodUnit = period = 60 * 5;\n      } else if (now - start <= daySec * 455) {\n        // until 455 days ago\n        periodUnit = period = 60 * 60;\n      } else {\n        // over 455 days, should return error, but try to long period\n        periodUnit = period = 60 * 60;\n      }\n    } else {\n      if (/^\\d+$/.test(target.period)) {\n        period = parseInt(target.period, 10);\n      } else {\n        period = kbn.interval_to_seconds(this.templateSrv.replace(target.period, options.scopedVars));\n      }\n    }\n    if (period < 1) {\n      period = 1;\n    }\n    if (!target.highResolution && range / period >= 1440) {\n      period = Math.ceil(range / 1440 / periodUnit) * periodUnit;\n    }\n\n    return period;\n  }\n\n  performTimeSeriesQuery(request: any) {\n    return this.awsRequest('/api/tsdb/query', request).then((res: any) => {\n      const data = [];\n\n      if (res.results) {\n        for (const query of request.queries) {\n          const queryRes = res.results[query.refId];\n          if (queryRes) {\n            for (const series of queryRes.series) {\n              const s = { target: series.name, datapoints: series.points } as any;\n              if (queryRes.meta.unit) {\n                s.unit = queryRes.meta.unit;\n              }\n              data.push(s);\n            }\n          }\n        }\n      }\n\n      return { data: data };\n    });\n  }\n\n  transformSuggestDataFromTable(suggestData: any) {\n    return _.map(suggestData.results['metricFindQuery'].tables[0].rows, v => {\n      return {\n        text: v[0],\n        value: v[1],\n      };\n    });\n  }\n\n  doMetricQueryRequest(subtype: any, parameters: any) {\n    const range = this.timeSrv.timeRange();\n    return this.awsRequest('/api/tsdb/query', {\n      from: range.from.valueOf().toString(),\n      to: range.to.valueOf().toString(),\n      queries: [\n        _.extend(\n          {\n            refId: 'metricFindQuery',\n            intervalMs: 1, // dummy\n            maxDataPoints: 1, // dummy\n            datasourceId: this.instanceSettings.id,\n            type: 'metricFindQuery',\n            subtype: subtype,\n          },\n          parameters\n        ),\n      ],\n    }).then((r: any) => {\n      return this.transformSuggestDataFromTable(r);\n    });\n  }\n\n  getRegions() {\n    return this.doMetricQueryRequest('regions', null);\n  }\n\n  getNamespaces() {\n    return this.doMetricQueryRequest('namespaces', null);\n  }\n\n  getMetrics(namespace: string, region: string) {\n    return this.doMetricQueryRequest('metrics', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n    });\n  }\n\n  getDimensionKeys(namespace: string, region: string) {\n    return this.doMetricQueryRequest('dimension_keys', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n    });\n  }\n\n  getDimensionValues(\n    region: string,\n    namespace: string,\n    metricName: string,\n    dimensionKey: string,\n    filterDimensions: {}\n  ) {\n    return this.doMetricQueryRequest('dimension_values', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      namespace: this.templateSrv.replace(namespace),\n      metricName: this.templateSrv.replace(metricName),\n      dimensionKey: this.templateSrv.replace(dimensionKey),\n      dimensions: this.convertDimensionFormat(filterDimensions, {}),\n    });\n  }\n\n  getEbsVolumeIds(region: string, instanceId: string) {\n    return this.doMetricQueryRequest('ebs_volume_ids', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      instanceId: this.templateSrv.replace(instanceId),\n    });\n  }\n\n  getEc2InstanceAttribute(region: string, attributeName: string, filters: any) {\n    return this.doMetricQueryRequest('ec2_instance_attribute', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      attributeName: this.templateSrv.replace(attributeName),\n      filters: filters,\n    });\n  }\n\n  getResourceARNs(region: string, resourceType: string, tags: any) {\n    return this.doMetricQueryRequest('resource_arns', {\n      region: this.templateSrv.replace(this.getActualRegion(region)),\n      resourceType: this.templateSrv.replace(resourceType),\n      tags: tags,\n    });\n  }\n\n  metricFindQuery(query: string) {\n    let region;\n    let namespace;\n    let metricName;\n    let filterJson;\n\n    const regionQuery = query.match(/^regions\\(\\)/);\n    if (regionQuery) {\n      return this.getRegions();\n    }\n\n    const namespaceQuery = query.match(/^namespaces\\(\\)/);\n    if (namespaceQuery) {\n      return this.getNamespaces();\n    }\n\n    const metricNameQuery = query.match(/^metrics\\(([^\\)]+?)(,\\s?([^,]+?))?\\)/);\n    if (metricNameQuery) {\n      namespace = metricNameQuery[1];\n      region = metricNameQuery[3];\n      return this.getMetrics(namespace, region);\n    }\n\n    const dimensionKeysQuery = query.match(/^dimension_keys\\(([^\\)]+?)(,\\s?([^,]+?))?\\)/);\n    if (dimensionKeysQuery) {\n      namespace = dimensionKeysQuery[1];\n      region = dimensionKeysQuery[3];\n      return this.getDimensionKeys(namespace, region);\n    }\n\n    const dimensionValuesQuery = query.match(\n      /^dimension_values\\(([^,]+?),\\s?([^,]+?),\\s?([^,]+?),\\s?([^,]+?)(,\\s?(.+))?\\)/\n    );\n    if (dimensionValuesQuery) {\n      region = dimensionValuesQuery[1];\n      namespace = dimensionValuesQuery[2];\n      metricName = dimensionValuesQuery[3];\n      const dimensionKey = dimensionValuesQuery[4];\n      filterJson = {};\n      if (dimensionValuesQuery[6]) {\n        filterJson = JSON.parse(this.templateSrv.replace(dimensionValuesQuery[6]));\n      }\n\n      return this.getDimensionValues(region, namespace, metricName, dimensionKey, filterJson);\n    }\n\n    const ebsVolumeIdsQuery = query.match(/^ebs_volume_ids\\(([^,]+?),\\s?([^,]+?)\\)/);\n    if (ebsVolumeIdsQuery) {\n      region = ebsVolumeIdsQuery[1];\n      const instanceId = ebsVolumeIdsQuery[2];\n      return this.getEbsVolumeIds(region, instanceId);\n    }\n\n    const ec2InstanceAttributeQuery = query.match(/^ec2_instance_attribute\\(([^,]+?),\\s?([^,]+?),\\s?(.+?)\\)/);\n    if (ec2InstanceAttributeQuery) {\n      region = ec2InstanceAttributeQuery[1];\n      const targetAttributeName = ec2InstanceAttributeQuery[2];\n      filterJson = JSON.parse(this.templateSrv.replace(ec2InstanceAttributeQuery[3]));\n      return this.getEc2InstanceAttribute(region, targetAttributeName, filterJson);\n    }\n\n    const resourceARNsQuery = query.match(/^resource_arns\\(([^,]+?),\\s?([^,]+?),\\s?(.+?)\\)/);\n    if (resourceARNsQuery) {\n      region = resourceARNsQuery[1];\n      const resourceType = resourceARNsQuery[2];\n      const tagsJSON = JSON.parse(this.templateSrv.replace(resourceARNsQuery[3]));\n      return this.getResourceARNs(region, resourceType, tagsJSON);\n    }\n\n    return this.$q.when([]);\n  }\n\n  annotationQuery(options: any) {\n    const annotation = options.annotation;\n    const statistics = _.map(annotation.statistics, s => {\n      return this.templateSrv.replace(s);\n    });\n    const defaultPeriod = annotation.prefixMatching ? '' : '300';\n    let period = annotation.period || defaultPeriod;\n    period = parseInt(period, 10);\n    const parameters = {\n      prefixMatching: annotation.prefixMatching,\n      region: this.templateSrv.replace(this.getActualRegion(annotation.region)),\n      namespace: this.templateSrv.replace(annotation.namespace),\n      metricName: this.templateSrv.replace(annotation.metricName),\n      dimensions: this.convertDimensionFormat(annotation.dimensions, {}),\n      statistics: statistics,\n      period: period,\n      actionPrefix: annotation.actionPrefix || '',\n      alarmNamePrefix: annotation.alarmNamePrefix || '',\n    };\n\n    return this.awsRequest('/api/tsdb/query', {\n      from: options.range.from.valueOf().toString(),\n      to: options.range.to.valueOf().toString(),\n      queries: [\n        _.extend(\n          {\n            refId: 'annotationQuery',\n            intervalMs: 1, // dummy\n            maxDataPoints: 1, // dummy\n            datasourceId: this.instanceSettings.id,\n            type: 'annotationQuery',\n          },\n          parameters\n        ),\n      ],\n    }).then((r: any) => {\n      return _.map(r.results['annotationQuery'].tables[0].rows, v => {\n        return {\n          annotation: annotation,\n          time: Date.parse(v[0]),\n          title: v[1],\n          tags: [v[2]],\n          text: v[3],\n        };\n      });\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    return (\n      this.templateSrv.variableExists(target.region) ||\n      this.templateSrv.variableExists(target.namespace) ||\n      this.templateSrv.variableExists(target.metricName) ||\n      _.find(target.dimensions, (v, k) => {\n        return this.templateSrv.variableExists(k) || this.templateSrv.variableExists(v);\n      })\n    );\n  }\n\n  testDatasource() {\n    /* use billing metrics for test */\n    const region = this.defaultRegion;\n    const namespace = 'AWS/Billing';\n    const metricName = 'EstimatedCharges';\n    const dimensions = {};\n\n    return this.getDimensionValues(region, namespace, metricName, 'ServiceName', dimensions).then(() => {\n      return { status: 'success', message: 'Data source is working' };\n    });\n  }\n\n  awsRequest(url: string, data: any) {\n    const options = {\n      method: 'POST',\n      url,\n      data,\n    };\n\n    return this.backendSrv.datasourceRequest(options).then((result: any) => {\n      return result.data;\n    });\n  }\n\n  getDefaultRegion() {\n    return this.defaultRegion;\n  }\n\n  getActualRegion(region: string) {\n    if (region === 'default' || _.isEmpty(region)) {\n      return this.getDefaultRegion();\n    }\n    return region;\n  }\n\n  getExpandedVariables(target: any, dimensionKey: any, variable: any, templateSrv: TemplateSrv) {\n    /* if the all checkbox is marked we should add all values to the targets */\n    const allSelected: any = _.find(variable.options, { selected: true, text: 'All' });\n    const selectedVariables = _.filter(variable.options, v => {\n      if (allSelected) {\n        return v.text !== 'All';\n      } else {\n        return v.selected;\n      }\n    });\n    const currentVariables = !_.isArray(variable.current.value)\n      ? [variable.current]\n      : variable.current.value.map((v: any) => {\n          return {\n            text: v,\n            value: v,\n          };\n        });\n    const useSelectedVariables =\n      selectedVariables.some((s: any) => {\n        return s.value === currentVariables[0].value;\n      }) || currentVariables[0].value === '$__all';\n    return (useSelectedVariables ? selectedVariables : currentVariables).map((v: any) => {\n      const t = angular.copy(target);\n      const scopedVar: any = {};\n      scopedVar[variable.name] = v;\n      t.refId = target.refId + '_' + v.value;\n      t.dimensions[dimensionKey] = templateSrv.replace(t.dimensions[dimensionKey], scopedVar);\n      if (variable.multi && target.id) {\n        t.id = target.id + window.btoa(v.value).replace(/=/g, '0'); // generate unique id\n      } else {\n        t.id = target.id;\n      }\n      return t;\n    });\n  }\n\n  expandTemplateVariable(targets: any, scopedVars: ScopedVars, templateSrv: TemplateSrv) {\n    // Datasource and template srv logic uber-complected. This should be cleaned up.\n    return _.chain(targets)\n      .map(target => {\n        if (target.id && target.id.length > 0 && target.expression && target.expression.length > 0) {\n          return [target];\n        }\n\n        const variableIndex = _.keyBy(templateSrv.variables, 'name');\n        const dimensionKey = _.findKey(target.dimensions, v => {\n          const variableName = templateSrv.getVariableName(v);\n          return templateSrv.variableExists(v) && !_.has(scopedVars, variableName) && variableIndex[variableName].multi;\n        });\n\n        if (dimensionKey) {\n          const multiVariable = variableIndex[templateSrv.getVariableName(target.dimensions[dimensionKey])];\n          return this.getExpandedVariables(target, dimensionKey, multiVariable, templateSrv);\n        } else {\n          return [target];\n        }\n      })\n      .flatten()\n      .value();\n  }\n\n  convertToCloudWatchTime(date: any, roundUp: any) {\n    if (_.isString(date)) {\n      date = dateMath.parse(date, roundUp);\n    }\n    return Math.round(date.valueOf() / 1000);\n  }\n\n  convertDimensionFormat(dimensions: any, scopedVars: ScopedVars) {\n    const convertedDimensions: any = {};\n    _.each(dimensions, (value, key) => {\n      convertedDimensions[this.templateSrv.replace(key, scopedVars)] = this.templateSrv.replace(value, scopedVars);\n    });\n    return convertedDimensions;\n  }\n}\n","import './query_parameter_ctrl';\n\nimport CloudWatchDatasource from './datasource';\nimport { CloudWatchQueryCtrl } from './query_ctrl';\nimport { CloudWatchConfigCtrl } from './config_ctrl';\n\nclass CloudWatchAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport {\n  CloudWatchDatasource as Datasource,\n  CloudWatchQueryCtrl as QueryCtrl,\n  CloudWatchConfigCtrl as ConfigCtrl,\n  CloudWatchAnnotationsQueryCtrl as AnnotationsQueryCtrl,\n};\n","import './query_parameter_ctrl';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { auto } from 'angular';\n\nexport class CloudWatchQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  aliasSyntax: string;\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    super($scope, $injector);\n    this.aliasSyntax = '{{metric}} {{stat}} {{namespace}} {{region}} {{<dimension name>}}';\n  }\n}\n","import angular, { IQService } from 'angular';\nimport coreModule from 'app/core/core_module';\nimport _ from 'lodash';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport DatasourceSrv from 'app/features/plugins/datasource_srv';\n\nexport class CloudWatchQueryParameterCtrl {\n  /** @ngInject */\n  constructor($scope: any, templateSrv: TemplateSrv, uiSegmentSrv: any, datasourceSrv: DatasourceSrv, $q: IQService) {\n    $scope.init = () => {\n      const target = $scope.target;\n      target.namespace = target.namespace || '';\n      target.metricName = target.metricName || '';\n      target.statistics = target.statistics || ['Average'];\n      target.dimensions = target.dimensions || {};\n      target.period = target.period || '';\n      target.region = target.region || 'default';\n      target.id = target.id || '';\n      target.expression = target.expression || '';\n      target.highResolution = target.highResolution || false;\n\n      $scope.regionSegment = uiSegmentSrv.getSegmentForValue($scope.target.region, 'select region');\n      $scope.namespaceSegment = uiSegmentSrv.getSegmentForValue($scope.target.namespace, 'select namespace');\n      $scope.metricSegment = uiSegmentSrv.getSegmentForValue($scope.target.metricName, 'select metric');\n\n      $scope.dimSegments = _.reduce(\n        $scope.target.dimensions,\n        (memo, value, key) => {\n          memo.push(uiSegmentSrv.newKey(key));\n          memo.push(uiSegmentSrv.newOperator('='));\n          memo.push(uiSegmentSrv.newKeyValue(value));\n          return memo;\n        },\n        []\n      );\n\n      $scope.statSegments = _.map($scope.target.statistics, stat => {\n        return uiSegmentSrv.getSegmentForValue(stat);\n      });\n\n      $scope.ensurePlusButton($scope.statSegments);\n      $scope.ensurePlusButton($scope.dimSegments);\n      $scope.removeDimSegment = uiSegmentSrv.newSegment({\n        fake: true,\n        value: '-- remove dimension --',\n      });\n      $scope.removeStatSegment = uiSegmentSrv.newSegment({\n        fake: true,\n        value: '-- remove stat --',\n      });\n\n      if (_.isEmpty($scope.target.region)) {\n        $scope.target.region = 'default';\n      }\n\n      if (!$scope.onChange) {\n        $scope.onChange = () => {};\n      }\n    };\n\n    $scope.getStatSegments = () => {\n      return $q.when(\n        _.flatten([\n          angular.copy($scope.removeStatSegment),\n          _.map($scope.datasource.standardStatistics, s => {\n            return uiSegmentSrv.getSegmentForValue(s);\n          }),\n          uiSegmentSrv.getSegmentForValue('pNN.NN'),\n        ])\n      );\n    };\n\n    $scope.statSegmentChanged = (segment: any, index: number) => {\n      if (segment.value === $scope.removeStatSegment.value) {\n        $scope.statSegments.splice(index, 1);\n      } else {\n        segment.type = 'value';\n      }\n\n      $scope.target.statistics = _.reduce(\n        $scope.statSegments,\n        (memo, seg) => {\n          if (!seg.fake) {\n            memo.push(seg.value);\n          }\n          return memo;\n        },\n        []\n      );\n\n      $scope.ensurePlusButton($scope.statSegments);\n      $scope.onChange();\n    };\n\n    $scope.ensurePlusButton = (segments: any) => {\n      const count = segments.length;\n      const lastSegment = segments[Math.max(count - 1, 0)];\n\n      if (!lastSegment || lastSegment.type !== 'plus-button') {\n        segments.push(uiSegmentSrv.newPlusButton());\n      }\n    };\n\n    $scope.getDimSegments = (segment: any, $index: number) => {\n      if (segment.type === 'operator') {\n        return $q.when([]);\n      }\n\n      const target = $scope.target;\n      let query = $q.when([]);\n\n      if (segment.type === 'key' || segment.type === 'plus-button') {\n        query = $scope.datasource.getDimensionKeys($scope.target.namespace, $scope.target.region);\n      } else if (segment.type === 'value') {\n        const dimensionKey = $scope.dimSegments[$index - 2].value;\n        delete target.dimensions[dimensionKey];\n        query = $scope.datasource.getDimensionValues(\n          target.region,\n          target.namespace,\n          target.metricName,\n          dimensionKey,\n          target.dimensions\n        );\n      }\n\n      return query.then($scope.transformToSegments(true)).then(results => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy($scope.removeDimSegment));\n        }\n        return results;\n      });\n    };\n\n    $scope.dimSegmentChanged = (segment: any, index: number) => {\n      $scope.dimSegments[index] = segment;\n\n      if (segment.value === $scope.removeDimSegment.value) {\n        $scope.dimSegments.splice(index, 3);\n      } else if (segment.type === 'plus-button') {\n        $scope.dimSegments.push(uiSegmentSrv.newOperator('='));\n        $scope.dimSegments.push(uiSegmentSrv.newFake('select dimension value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      $scope.syncDimSegmentsWithModel();\n      $scope.ensurePlusButton($scope.dimSegments);\n      $scope.onChange();\n    };\n\n    $scope.syncDimSegmentsWithModel = () => {\n      const dims: any = {};\n      const length = $scope.dimSegments.length;\n\n      for (let i = 0; i < length - 2; i += 3) {\n        const keySegment = $scope.dimSegments[i];\n        const valueSegment = $scope.dimSegments[i + 2];\n        if (!valueSegment.fake) {\n          dims[keySegment.value] = valueSegment.value;\n        }\n      }\n\n      $scope.target.dimensions = dims;\n    };\n\n    $scope.getRegions = () => {\n      return $scope.datasource\n        .metricFindQuery('regions()')\n        .then((results: any) => {\n          results.unshift({ text: 'default' });\n          return results;\n        })\n        .then($scope.transformToSegments(true));\n    };\n\n    $scope.getNamespaces = () => {\n      return $scope.datasource.metricFindQuery('namespaces()').then($scope.transformToSegments(true));\n    };\n\n    $scope.getMetrics = () => {\n      return $scope.datasource\n        .metricFindQuery('metrics(' + $scope.target.namespace + ',' + $scope.target.region + ')')\n        .then($scope.transformToSegments(true));\n    };\n\n    $scope.regionChanged = () => {\n      $scope.target.region = $scope.regionSegment.value;\n      $scope.onChange();\n    };\n\n    $scope.namespaceChanged = () => {\n      $scope.target.namespace = $scope.namespaceSegment.value;\n      $scope.onChange();\n    };\n\n    $scope.metricChanged = () => {\n      $scope.target.metricName = $scope.metricSegment.value;\n      $scope.onChange();\n    };\n\n    $scope.transformToSegments = (addTemplateVars: any) => {\n      return (results: any) => {\n        const segments = _.map(results, segment => {\n          return uiSegmentSrv.newSegment({\n            value: segment.text,\n            expandable: segment.expandable,\n          });\n        });\n\n        if (addTemplateVars) {\n          _.each(templateSrv.variables, variable => {\n            segments.unshift(\n              uiSegmentSrv.newSegment({\n                type: 'template',\n                value: '$' + variable.name,\n                expandable: true,\n              })\n            );\n          });\n        }\n\n        return segments;\n      };\n    };\n\n    $scope.init();\n  }\n}\n\nexport function cloudWatchQueryParameter() {\n  return {\n    templateUrl: 'public/app/plugins/datasource/cloudwatch/partials/query.parameter.html',\n    controller: CloudWatchQueryParameterCtrl,\n    restrict: 'E',\n    scope: {\n      target: '=',\n      datasource: '=',\n      onChange: '&',\n    },\n  };\n}\n\ncoreModule.directive('cloudwatchQueryParameter', cloudWatchQueryParameter);\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAQA;AACA;AAJA;AACA;AAqBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA4CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAlFA;AAmFA;AAAA;AApFA;;;;;;;;;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAAA;AAMA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AAEA;;AACA;AAAA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AACA;;;;;;;;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACrfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAEA;AADA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;ACVA;AACA;AAGA;AAAA;AAKA;AACA;AAAA;AAEA;;AACA;AARA;AASA;AAAA;AAVA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;A","sourceRoot":""}